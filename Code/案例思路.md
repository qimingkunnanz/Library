---

---

# 计算鼠标在盒子内的坐标

x = e.pageX - box.offsetLeft

y = e.pageY - box.offsetTop

e.page为鼠标基于body的坐标 box.offsetTop为盒子基于body的坐标

# 缓动动画公式

步长=（目标值-现在位置）/10    步长：每次移动的距离

匀速动画：当前位置+固定值

缓动动画：当前位置+变小的值

# 回调函数

将一个匿名函数作为参数（实参）传递 那么这个函数就是回调函数 传参的过程就是赋值的过程

```js
function animate(obj,targer,callback) {
    
}
animate(span,800,function () {});
// 传参的过程时赋值过程
// callback时形参，形参是一个局部变量，变量可以赋值
// callback这个变量保存的是匿名函数
callback = function () {}
```



# 放大镜

```php+HTML
<div class="preview_img">
    <img src="upload/s3.png" alt="">
    <div class="mask"></div>
    <div class="big">
    	<img src="upload/big.jpg" alt="" class="bigImg">
    </div>
</div>
```



```js
window.addEventListener('load', function(e) {
  // 1.获取元素
  // 获取黄色遮盖层盒子
  var mask = document.querySelector('.mask');
  var preview_img = document.querySelector('.preview_img');
  var big = document.querySelector('.big');
  // 2.绑定事件
  // 当鼠标移动至preview_img时黄色盒子显示
  preview_img.addEventListener('mouseover', function(e) {
    mask.style.display = 'block'
    big.style.display = 'block'
  });
  // 当鼠标移动出preview_img时黄色盒子隐藏
  preview_img.addEventListener('mouseout', function(e) {
    mask.style.display = 'none'
    big.style.display = 'none'
  });
  // 3.黄色盒子跟随鼠标移动但是不能超过父盒子的大小
  preview_img.addEventListener('mousemove', function(e) {
    var x = e.pageX - this.offsetLeft;
    var y = e.pageY - this.offsetTop;
    // 设置鼠标位于黄盒子的中心
    var maskx = x - mask.offsetWidth / 2;
    var masky = y - mask.offsetHeight / 2;
    // 3.1不能超过父盒子的大小
    var maskXmax = preview_img.offsetWidth - mask.offsetWidth;
    var maskYmax = preview_img.offsetHeight - mask.offsetHeight;
    // 当数值小于等于0时给maskx赋值为0，当数值大于等于父盒子时给maskx赋值为父盒子最大宽度
    if (maskx <= 0) {
      maskx = 0;
    } else if (maskx >= maskXmax) {
      maskx = maskXmax;
    }
    if (masky <= 0) {
      masky = 0;
    } else if (masky >= maskYmax) {
      masky = maskYmax;
    }
    // 最后不断赋值给黄盒子
    mask.style.left = maskx + 'px';
    mask.style.top = masky + 'px';
    // 4.实现大图片跟随小图片的移动而移动
    // 获取大图片元素
    var bigImg = document.querySelector('.bigImg');
    // 大图片的最大移动距离
    var bigXmax = bigImg.offsetWidth - big.offsetWidth;
    var bigYmax = bigImg.offsetHeight - big.offsetHeight;
    // 大图片跟随小图片等比例移动
    var bigx = maskx * bigXmax / maskXmax;
    var bigy = masky * bigYmax / maskYmax;
    // 最后赋值给大图片
    bigImg.style.left = -bigx + 'px';
    bigImg.style.top = -bigy + 'px';
  });
});
```

# 模仿淘宝固定侧边栏

```html
  <div class="slider-bar"><!-- 侧边栏 -->
    <span class="goBack">返回顶部</span>
  </div>
  <div class="header w">头部区域</div>
  <div class="banner w">banner区域</div>
  <div class="main w">主体部分</div>
```



```js
    //   1.获取元素
    // 获取侧边栏元素
    var sliderbar = document.querySelector('.slider-bar');
    // 获取头部区域元素
    var banner = document.querySelector('.banner');
    // banner.offsetTop被卷去头部的大小，一定要写在滚动函数外
    var bannertop = banner.offsetTop;
    // 获取main 主体部分元素
    var main = document.querySelector('.main');
    var maintop = main.offsetTop;
    // 获取返回顶部元素 ，到达主体部分时显示元素
    var goBack = document.querySelector('.goBack');
    // 2.绑定页面滚动事件
    document.addEventListener('scroll', function(e) {
      // pageYOffset:页面被卷去的部分
      // 当页面向下滚动时slider-bar变为固定定位，否则变为相对定位距离top 300px
      if (window.pageYOffset >= bannertop) {
        sliderbar.style.position = 'fixed'
        sliderbar.style.top = bannertop + 'px'
      } else {
        sliderbar.style.position = 'absolute'
        sliderbar.style.top = '300px'
      }
      // 当页面滚动到main盒子时，显示goback,否则为隐藏
      if (window.pageYOffset >= maintop) {
        goBack.style.display = 'block'
      } else {
        goBack.style.display = 'none'
      }
    });
```

# 拖动盒子

```html
  <div class="login-header"><a id="link" href="javascript:;">点击，弹出登录框</a></div>
  <div id="login" class="login">
    <div id="title" class="login-title">登录会员
      <span><a id="closeBtn" href="javascript:void(0);" class="close-login">关闭</a></span>
    </div>
    <div class="login-input-content">
      <div class="login-input">
        <label>用户名：</label>
        <input type="text" placeholder="请输入用户名" name="info[username]" id="username" class="list-input">
      </div>
      <div class="login-input">
        <label>登录密码：</label>
        <input type="password" placeholder="请输入登录密码" name="info[password]" id="password" class="list-input">
      </div>
    </div>
    <div id="loginBtn" class="login-button"><a href="javascript:void(0);" id="login-button-submit">登录会员</a></div>
  </div>
  <!-- 遮盖层 -->
  <div id="bg" class="login-bg"></div>
```



```js
    // 1.获取元素
    // 获取点击出现登陆框的元素
    var link = document.querySelector('#link');
    // 获取登陆框元素
    var login = document.querySelector('#login');
    // 获取遮罩层元素
    var bg = document.querySelector('#bg');
    // 获取关闭元素
    var closeBtn = document.querySelector('#closeBtn');
    // 获取标题元素
    var title = document.querySelector('#title');
    // 2.绑定事件
    // 鼠标点击时登陆框、遮罩层显示
    link.addEventListener('click', function(e) {
      login.style.display = 'block';
      bg.style.display = 'block';
    });
    // 鼠标点击时登陆框、遮罩层隐藏
    closeBtn.addEventListener('click', function(e) {
      login.style.display = 'none';
      bg.style.display = 'none';
    });
    // 3.拖拽login框
    // 鼠标按下时触发
    title.addEventListener('mousedown', function(e) {
      // 获取鼠标在登陆框的坐标
      var x = e.pageX - login.offsetLeft;
      var y = e.pageY - login.offsetTop; //这里拖拽的不是title而是login框
      // 3.1login框跟随鼠标移动
      document.addEventListener('mousemove', move);
      // 为登陆框赋值使其跟随鼠标的移动而移动
      function move(e) {
        login.style.left = e.pageX - x + 'px';
        login.style.top = e.pageY - y + 'px';
      }
      // 鼠标弹起时取消鼠标移动方法
      document.addEventListener('mouseup', function(e) {
        document.removeEventListener('mousemove', move)
      });
    });
```

# 倒计时效果

```html
<div>
  <span class="hour">1</span>
  <span class="minute">2</span>
  <span class="second">3</span>
</div>
```

```js
    // 1.获取元素
    // 获取第一个盒子
    var hour = document.querySelector('.hour');
    // 获取第二个盒子
    var minute = document.querySelector('.minute');
    // 获取第三个盒子
    var second = document.querySelector('.second');
    // 3.2使用设定的未来时间减去当前时间达到倒数的效果
    var inputTime = +new Date('2019-4-27 20:00:00'); // 返回的是用户输入时间总的毫秒数
    // 4.提前调用一次,避免刷新出现空白
    countDown();
    // 2.设置定时器
    setInterval(countDown, 1000);
    // 3.1 设置一个时间函数

    function countDown() {
      var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
      var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 
      var h = parseInt(times / 60 / 60 % 24); // 剩余的小时
      h = h < 10 ? '0' + h : h;
      hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子
      var m = parseInt(times / 60 % 60); // 剩余的分钟
      m = m < 10 ? '0' + m : m;
      minute.innerHTML = m;
      var s = parseInt(times % 60); // 剩余的秒数
      s = s < 10 ? '0' + s : s;
      second.innerHTML = s;
    }
```

# 发送短信

```html
手机号码： <input type="number"> <button>发送</button>
```



```js
// 1.获取元素
var btn = document.querySelector('button');
// 2.2设置时长
var data = 3;
// 2.绑定事件
btn.addEventListener('click', function(e) {
  // 2.1使按钮禁用
  this.disabled = true;
  // 3.设置倒计时
  // 3.2先调用一次函数,避免数字1秒后出现
  timer();
  var tim = setInterval(timer, 1000);
});
// 3.1设置一个倒计时函数
function timer() {
  // 3.判断当时间为0时清除定时器,否则时间递减
  if (data == 0) {
    // 取消按钮禁用状态
    btn.disabled = false;
    // 按钮中的文字显示为发送
    btn.innerHTML = '发送';
    // 4.清除定时器
    clearInterval(tim);
    // 重新赋值时长
    data = data;
  } else {
    // 否则 就倒计时
    btn.innerHTML = data;
    data--;
  }
}
```

# 5秒后跳转（使用较多）

```js
<div></div>
```

```js
// 1.获取元素
var div = document.querySelector('div');
// 2.button的点击事件
btn.addEventListener('click', function(e) {
  location.href = 'https://tool.lu/timestamp/'
});
// 2.页面自动跳转
var time = 5;
// 设置一个周期性定时器
setInterval(function() {
  if (time == 0) {
    // 跳转页面（需要联网）
    location.href = 'https://tool.lu/timestamp/'
  } else {
    // 否则开始倒计时
    div.innerHTML = '您将在' + time + '秒后跳转至https://tool.lu/timestamp/';
    time--;
  }
}, 1000);
```

# 事件委托

```js
// 利用冒泡思想实现，给父节点绑定事件，而不是给子节点绑定
// 将事件委托给父节点
var ul = document.querySelector('ul');
ul.addEventListener('click', function(e) {
  alert('sfe,ss')
  e.target.style.color = 'red'
});
```

# 全选反选

```js
// 1.获取元素
// 获取全选按钮
var j_cbAll = document.querySelector('#j_cbAll');
// 获取所有单选按钮
var j_tb = document.querySelector('#j_tb').querySelectorAll('input');
// 1.点击全选所有checked都选中
j_cbAll.onclick = function() {
  for (let i = 0; i < j_tb.length; i++) {
    j_tb[i].checked = this.checked
  }
};
// 2.所有checked都选中 全选框才被选中
for (let i = 0; i < j_tb.length; i++) {
  j_tb[i].onclick = function() {
    // 循环判断单选框是否都被选中
    for (let i = 0; i < j_tb.length; i++) {
      if (j_tb[i].checked == false) {
        j_cbAll.checked = false
        break;
      }
      j_cbAll.checked = true
    }
  }
}
```

# 动态生成表格

```html
<thead>
  <tr>
    <th>姓名</th>
    <th>科目</th>
    <th>成绩</th>
    <th>操作</th>
  </tr>
</thead>
```

```js
var tbody = document.querySelector('tbody');
for (var i = 0; i < datas.length; i++) {
var tr = document.createElement('tr');
tbody.appendChild(tr);
// 3.创建单元格
for (const k in datas[i]) {
  var td = document.createElement('td');
  td.innerHTML = datas[i][k]
  tr.appendChild(td);
}
// 4.创建删除单元格
var td = document.createElement('td');
td.innerHTML = '<a href="javascript:;">删除</a>'
tr.appendChild(td);
// 5.为所有a添加事件
var lina = document.querySelectorAll('a');
for (let i = 0; i < lina.length; i++) {
  lina[i].onclick = function() {
    tbody.removeChild(this.parentNode.parentNode);
  }
}
```

# 轮播图

```html
<div class="focus fl">
    <!-- 左侧按钮 -->
    <a href="javascript:;" class="arrow-l">
        &lt;
        </a>
    <!-- 右侧按钮 -->
    <a href="javascript:;" class="arrow-r">  </a>
    <!-- 核心的滚动区域 -->
    <ul>
        <li>
            <a href="#"><img src="upload/focus.jpg" alt=""></a>
        </li>
        <li>
            <a href="#"><img src="upload/focus1.jpg" alt=""></a>
        </li>
        <li>
            <a href="#"><img src="upload/focus2.jpg" alt=""></a>
        </li>
        <li>
            <a href="#"><img src="upload/focus3.jpg" alt=""></a>
        </li>
    </ul>
    <!-- 小圆圈 -->
    <ol class="circle">

    </ol>
</div>
```

```js
// 1.使所有图片一行显示
// 2.实现滚动效果

window.addEventListener('load', function(e) {
  // 1.获取元素
  var focus = document.querySelector('.focus');
  var arrowl = document.querySelector('.arrow-l');
  var arrowr = document.querySelector('.arrow-r');
  // 2.绑定事件
  // 2.1鼠标经过时显示箭头
  focus.addEventListener('mousemove', function(e) {
    arrowl.style.display = 'block'
    arrowr.style.display = 'block'
  });
  // 2.1鼠标离开时隐藏箭头
  focus.addEventListener('mouseout', function(e) {
    arrowl.style.display = 'none'
    arrowr.style.display = 'none'
  });
  // 3.动态显示小圆圈
  // 3.1获取ul 和ol
  var ul = focus.querySelector('ul');
  var circle = document.querySelector('.circle');
  //   children:数组
  // 3.2循环创建小圆点 ，使用ul.children.length获取ul中有几个li然后在ol中创建几个li
  for (let i = 0; i < ul.children.length; i++) {
    // 创建li元素节点
    var li = document.createElement('li');
    // 添加到指定位置
    circle.appendChild(li);
  };
  // 3.3选中的小圆圈高亮显示
  circle.children[0].className = 'current'
});
```

## 3.3选中的小圆圈高亮显示 , 使用排他思想

### 方法一：在创建li的同时添加高亮（代码的效率会低一点）

```js
    li.addEventListener('click', function(e) {
        for (let i = 0; i < circle.children.length; i++) {
        for (let i = 0; i < circle.children.length; i++) {
            circle.children[i].className = '';
        }
        this.className = 'current';
        }
    });
```

### 方法二： 使用proxy代理的方式 写在添加li的外面

```js
  circle.addEventListener('click', function(e) {
    for (let i = 0; i < circle.children.length; i++) {
      circle.children[i].className = '';

    }
    // e.target:拿到当前的小li
    e.target.className = 'current';
  });
```

```js
// 1.使所有图片一行显示
// 2.实现滚动效果

window.addEventListener('load', function(e) {
  // 1.获取元素
  var focus = document.querySelector('.focus');
  var arrowl = document.querySelector('.arrow-l');
  var arrowr = document.querySelector('.arrow-r');
  // 2.绑定事件
  // 2.1鼠标经过时显示箭头
  focus.addEventListener('mousemove', function(e) {
    arrowl.style.display = 'block';
    arrowr.style.display = 'block';
    // 8.1鼠标经过清除定时器停止自动播放
    clearInterval(timer);
    timer = null;
  });
  // 2.1鼠标离开时隐藏箭头
  focus.addEventListener('mouseout', function(e) {
    arrowl.style.display = 'none';
    arrowr.style.display = 'none';
    // 8.2鼠标离开开启定时器开启自动播放
    timer = setInterval(function() {
      arrowr.click();
    }, 2000);
  });
  // 3.动态显示小圆圈
  // 3.1获取ul 和ol
  var ul = focus.querySelector('ul');
  var circle = focus.querySelector('.circle');
  //5.2  4.2.2获取父盒子focus的宽度
  var focusWidth = focus.offsetWidth;
  //   children:数组
  // 3.2循环创建小圆点 ，使用ul.children.length获取ul中有几个li然后在ol中创建几个li
  for (let i = 0; i < ul.children.length; i++) {
    // 创建li元素节点
    var li = document.createElement('li');
    // 4.2.1给每个小li设置值定义属性
    li.setAttribute('index', i)
      // 添加到指定位置
    circle.appendChild(li);
    // 3.3选中的小圆圈高亮显示 , 使用排他思想）
    // 方法1 给每一个小li一个点击事件（代码的效率会低一点）
    li.addEventListener('click', function(e) {
      for (let i = 0; i < circle.children.length; i++) {
        for (let i = 0; i < circle.children.length; i++) {
          // 先清除其他小li的样式
          circle.children[i].className = '';
        }
        // 在给点击的那个li样式
        this.className = 'current';
        // 4.实现点击li图片滑动效果 (移动ul的位置)
        //   核心算法：小圆点的索引*父盒子发宽度
        // 4.1确定ul
        // 4.2.2获取小圆点的索引号
        var index = this.getAttribute('index');
        // 解决小bug:小圆圈和图片不同步问题
        num = index; // 同步图片
        xyq = index; // 小圆圈
        // 4.2确定坐标target = -index * focusWidth
        animate(ul, -index * focusWidth)
      }
    });
  };

  circle.children[0].className = 'current';
  // 3.3选中的小圆圈高亮显示 , 使用排他思想）
  //   //   方法2 使用proxy代理的方式
  //   circle.addEventListener('click', function(e) {
  //     for (let i = 0; i < circle.children.length; i++) {
  //       // 先清除其他小li的样式

  //       circle.children[i].className = '';

  //     }
  //     // e.target:拿到当前的小li
  //     在给点击的那个li样式

  //     e.target.className = 'current';
  //   });
  // 5.点击箭头滑动ul
  // 5.4克隆第一张图片放到ul的最后
  //   5.4.1克隆ul中的第一个li
  var first = ul.children[0].cloneNode(true);
  //   5.4.2挂载到ul中的最后一个位置
  ul.appendChild(first);
  // 5.1定义一个变量 ，用来装计算器（控制图片）
  var num = 0;
  // 6.1定义一个变量 ，用来装计算器（控制小圆圈）
  var xyq = 0;
  arrowr.addEventListener('click', function(e) {
    //   5.3使图片无缝切换
    if (num == ul.children.length - 1) {
      // 让ul回到原点
      ul.style.left = 0;
      num = 0;
    }
    num++;
    // target = -num * focusWidth
    animate(ul, -num * focusWidth);
    // 6.点击箭头，小圆圈跟随变化
    xyq++;
    // circle.children.length:小圆圈的个数
    if (xyq == circle.children.length) {
      xyq = 0;
    }
    circleChabge()
  });
  arrowl.addEventListener('click', function(e) {
    if (num == 0) {
      // 让ul回到原点
      num = ul.children.length - 1;
      ul.style.left = -num * focusWidth + 'px';
    }
    num--;
    // target = -num * focusWidth
    animate(ul, -num * focusWidth);
    // 6.点击箭头，小圆圈跟随变化
    xyq--;
    // circle.children.length:小圆圈的个数
    if (xyq < 0) {
      xyq = circle.children.length - 1;
    }
    // 7.1调用函数
    circleChabge()
  });
  //   7.封装函数
  function circleChabge() {
    // 6.2使用排他思想改变小圆圈的样式
    for (let i = 0; i < circle.children.length; i++) {
      circle.children[i].className = '';

    }
    circle.children[xyq].className = 'current'
  }
  //   8.自动播放图片（设置一个定时器，模拟右箭头点击事件）
  var timer = setInterval(function() {
    //   手动调用右箭头点击事件
    arrowr.click();
  }, 2000);
});
// 定义动画
// animate(obj, target,);
```

























