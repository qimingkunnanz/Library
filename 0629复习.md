1. flex布局，响应式开发(媒体查询)

2. 同步异步

   1. js是单线程的，所有的异步任务有宿主环境(浏览器或者nodejs)来实现；比较耗时的异步任务，宿主环境会开启子线程去处理
   2. 在异步任务队列里面，通过事件循环，js引擎将取出来的任务放到主线程里去执行；

3. 原型，原型链， 三角图

   ```
   1. 所有的函数都有一个prototype属性(原型对象)， 它是一个对象(本质上它是一个地址，指向一个对象)， 这个对象的用途共享所有的属性和方法 给对象实例； 这个原型对象也是对象，所有他也有原型__proto__
   2. 所有的对象都有一个__proto__属性(原型，私有属性)， 这个属性指向构造函数的原型， 它是一个非标准属性， 但是为对象的查找机制提供了一个方向， 它指向构造函数的原型对象
   3. constructor属性，  对象的原型__proto__和构造函数的原型对象prototype都有的一个属性   指回构造函数本身
   
   4. 每个对象实例都有一个__proto__属性， 这个属性指向构造函数的原型对象，构造函数的原型对象也是一个对象， 也有__proto__属性， 这样一层一层向上找，形成了原型链
   ```

4. 继承

   1. 借用父构造函数继承属性
   2. 借用原型对象继承方法

5. 常见数组迭代方法map/filter/forEach/every/some

6. 事件冒泡，事件委托，冒泡排序，排他算法

   ```
   1. 事件冒泡： DOM事件流的三个阶段  捕获-->当前目标阶段--->冒泡阶段， JS只能执行捕获或者冒泡的其中一个阶段，addEventListener()  第三个参数为true表示捕获阶段 (webapi第三天)
   2. 事件委托： 
   		//原生
   		// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
       var ul = document.querySelector('ul');
       ul.addEventListener('click', function(e) {
       	// e.target 这个可以得到我们点击的对象
       	// // 里面的e.target  和this 不一样
       	e.target.style.backgroundColor = 'pink';
       })
       
   		// jquery事件委派；
       $("ul").on("click", "li", function(e) {
           console.log(11);
         // 里面的e.target  和this 一样
       });
   3. 冒泡排序:
   
   4. 排他算法:
   		for(var i=0; i<dom.length; i++){
         dom[i].style.color = ''
   		}
   		this.style.color = 'red';
   		//jquery
   		$(this).addClass('acrive').siblings('a').removeClass('active')
   ```

7. 深拷贝(递归)， 闭包(一些考题)

8. ajax (xhr)

   1. 异步请求： 异步的工作里面的用到的库是  $.ajax,  resource, axios, rxjs



### 后台基本概念

1. nodejs基础知识点

   ```
   fs
   .readFile(),  .writeFile(), appendFile(), copyFile()， readdir()
   
   path
   .join(__dirname, 'my.txt')
   
   __filename
   ```

2. 模块(面试)

   1. 就是一种规范； 以前的时候 nodejs端使用 commonjs规范； 浏览器端使用 AMD/CMD规范

      ```javascript
      const fs = require('fs);  // 核心模块，第三方模块，自定义模块
      
      module.exports = a;
      module.exports = {
        sayHi: sayHi
      }
      ```

   2. 现在一般使用es6的模块化规范，语言层面上，浏览器基本已经实现，nodejs有的还不支持，，需要使用babel  es2018  2019

      ```javascript
      export let radius = 1;
      export default f;
      
      import c from 'fmod';
      import {f} from 'fmod'
      import * as circle from './circle.js'
      ```

3. web服务器

   1. 传统的web服务器， apache，nginx，IIS； 服务器也是一台电脑，只不过专门给请求的客户端电脑一些响应；  B/S交互模型，  请求--处理--响应

   2. 使用一个web服务器框架搭建服务器

      ```
      res.send()
      res.sendFile()
      res.render()
      获取数据： req.query, req.params, res.body
      ejs, art-template 模板引擎
      
      路由： 就是一种对应关系， 前台请求一个地址，后台服务器对应有一个地址监听，并且给响应
      中间件： 内置一个中间件 express.static()
      				很多自定义中间件， 常见的 app.use(router) 抽离路由模块，应用级别中间件
      数据库： 使用过mysql，了解redis，mongodb等
      				
      				
      以后工作中，搭建一个简易的服务器, 脚手架
        npm install express-generator -g
        express -v ejs 项目名  // 会以项目名创建一个文件夹，项目文件放到文件夹里面
        //express -v ejs         // 把项目文件放在当前文件夹(当前文件夹非空会有警告)
        npm install
        npm run start // 启动项目
      ```

   3. 英雄列表/乐淘： 前后端分离的开发模式

      1. 在之前的工作中，我们团队采用的是前后端分离的开发模式；我们写前台页面，需要调用接口的时候，就去查后台给我们提供的接口文档，不过这种模式常见的就是跨域问题，一般解决方案是jsonp，但他不支持post请求；发送的也不是ajax请求，是动态创建的script标签；我们后台采用的是cors的模式；服务器层面上允许跨域
      2. (不要说什么前端在3001端口，后端在5001端口，我们这个英雄列表是我们即写前台，有写了后台；工作里面我们只会写前台页面；开发需要接口的数据时；再去请求后台的接口，查看接口文档)
      3. 之前工作中，我做了一个订单页面数据的增删改查；主要的流程就是先使用假数据写一个静态页面，使用过bootstrap，semetic-ui的框架；然后根据公司的ui设计画的图，对这些框架做了一些二次开发，增加了一些自己的样式；团队中每个人的样式都会加上自己的名称或一个字母作为自己写的css前缀；这样可以保证自己写的样式不会和别人的冲突；调试bug也非常简单；还有对于一些框架没有提供的插件，或者不好用的插件，例如树形控件，下拉列表插件，分页插件，图片上传插件 我一般都会去github上找比较好的第三方插件；并集成到自己的项目中。  这些工作都做完后，我才是去查看接口文档，对应的写一些ajax请求，将数据获取后，使用模板引擎将数据动态渲染到之前放假数据的位置上。不过后面我自学了vue之后，这种方式就少用了；因为要写模板引擎，比较的麻烦，使用vue之后根本就不用操作DOM结构，仅仅只用关心数据就好，因为核心理念是数据驱动视图

   4. 黑马博客，自己写后台，自己写前端，使用模板引擎渲染页面

      1. 这个看情况，可说可不说；我之前公司的后台人员开发的模式我看过，他们项目的核心理念是，我们是全栈开发工程师；自己先设计好数据库，然后写后台服务器，各种第三方插件的使用，利用了几个第三方框架express-session做session的存储，和cookie结合使用保持用户的登录状态，bcrypt一种比md5更安全的加密方式，在数据库里面存的都是加密过的密码，这样保证了用户数据的安全性，即使数据库泄露也不用担心比人看见密码。这个项目的开发流程比如说显示文章详情， 先是写后台接口，然后调整好sql语句，检验从数据库里面查询出来的结果是否是什么，整理一下，使用res.render 将ejs模板和数据拼接好发送给前台显示；这种是服务器直接返回一个页面，前后端分离是返回一组数据，我们前台js自己拼接，乐淘就是发送ajax请求，然后将返回的数据动态拼接成html字符串，再显示出来





1. 前后端是什么意思？
   1. 前端就是我们的html页面----前端开发工程师
   2. 后端就是我们用express写的服务器---- 后端开发工程师
   3. 前后的链接是通过 ajax；  前端通过一个按钮点击了之后， 发送ajax请求，(请求可以是get，post等等)， 后台会根据你请求的路径(例如/login)和请求的类型(post、get等), 去找到对应的路由，然后做出响应
   4. 我对服务器做的一些优化？  保证各种模块功能的单一性， 抽离各种模块（比如 路由，数据库模块，控制器模块， 工具函数模块）
2. MVC --- MVVM
   1. Model层-----db文件夹-- 数据库
   2. View层----views文件夹----html文件
   3. Controller层----业务逻辑controller、router、app.js 一起都叫控制层
   4. 浏览器输入`http://127.0.0.1/login`, 后面的走向
      1. 第一步： 入口函数 app.js
      2. 第二步： 进入路由router模块， 查找对应的 /login地址和请求类型post/get
      3. 第三步： 进入控制器controller模块， 在这个里面 会调用一些第三方库，momentjs， mysql；
      4. 第四步： 就是服务器控制器里面的 返回； 前台在ajax， success回调函数里面接受服务器的返回， 然后显示到页面上，或者给个错误的提示
3. cookie，session
   1. cookie 是浏览器客户端的一个技术， 每次请求的时候，cookie跟随浏览器的请求头，发送给服务器
   2. session 是服务器端的一个技术， 每次用户登录成功之后， 把用户的信息保存到session里面(它是在服务器里面开辟的一个内存空间，一个具体的位置)；
   3. 他们的过期时间， 当前会话期间；完善生命周期。 服务器删除seesion， 前端即使传递了对应的sessionID也会匹配不到，所以相当于登录状态就没有了。 cookie的声明周期， 和过期时间设置与否有关， 如果没有设置，当前浏览器关闭就没有了或者说失效了； 如果设置了，就按过期时间来算
   4. 服务器给浏览器发送的是一个sessionID，浏览器的cookie保存了这个值，下次请求的时候会自动带上这个id传给服务器。 如果查到并且匹配，那么就显示登录成功，就不用再登录了； 否则重新登录
   5. 他们搭配使用， 可以保存用户的登录状态
4. web开发模式
   1. 了解过 前后分离的开发模式；  了解过后台程序员即写后台又写前端的开发模式(页面使用模板引擎)
5. 跨域
   1. JSONP， 原理是利用script 脚本的形式实现的， 不能实现post； 前端技术
   2. cors， 这是后台的一个技术  ` www.163.com `可以访问`news.163.com`s
6. 第三方框架
   1. bootstrap， semantic-ui，