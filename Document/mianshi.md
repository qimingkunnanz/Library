css优化:-->精灵图 使用定位改变图片位置显示不同图片

## localstorage sessionstorage cookie session

```js
let str=[
    {name:'as',sge:12}
    {name:'as',sge:12}
]
localstorage.setItem('k','v'/字符串)
localstorage.getItem('k')
localstorage.setItem(JSON.stringify(str))数组转字符串 储存
使用push添加 必须字符串转数组
str.push(JSON.parse(JSON.stringify(str)))
```

webapp传输数据 localstorage sessionstorage

localstorage:一致存在

cookie的有效期

1. 浏览器关闭就失效
2. 设置了过期时间,过了事件失效

session的生命周期

1. 不主动销毁一直存在
2. session是一门通用技术,在服务器开窍一个栈空间,存放每一个用户的相关信息
3. 如果设置了过期时间超过时间就结束
4. 没有设置时间默认关闭浏览器时结束周期
5. session有默认过期时间(20-30分钟). 删除session删除的是当前用户信息session还存在于浏览器中只是无法找到响应的用户信息,这样就达到了我们想要的效果

配合使用 可以用于保存用户的登陆状态

1. 当登陆成功时将用户的信息会存储在cookie中,将当前用户id从cookie中获取并保存在session中,session会开辟了一个栈空间存储当前id(一个用户开辟一个栈空间,形成一个一一对应的关系)保存在服务器中,这样下次开启页面时浏览器携带用户id发送请求给服务器,服务器响应并在栈空间中查找,找到相应的数据后携带数据返回给浏览器,这样就达到了保存用户登陆状态的效果



## 事件执行机制:

1. 捕获(从上至下) -->目标阶段 --> 冒泡(从下至上)
2. 只会执行一个阶段,使用较多的冒泡

```
事件委托
str.addEventListener('click',function(e){
	e.atrget 可以获取点击的对象
})
jQuery中的this和e.atrget是一样的
```



## 同步异步

1. js 的单线程异步非阻塞式语言

   > js是单线程 所有的异步任务都是由浏览器处理的

   1. 单线程
      1. 是一个同步任务，当一个任务执行结束后才会执行下一个任务
   2. 异步
      1. 将耗时的操作放入任务列表中
      2. 在需要时候释放出来，提高执行效率 提高js解析引擎的工作效率
   3. 非阻塞式
      1. 当代码中有耗时的任务时，就将这个任务放到任务列表中。满足相应的条件时再执行这个任务 

------

抽离公共模块,添加页面的可读性

抽离模块使页面性能单一提高了文件的可读性

------



## 引插件

1. 引入文件

2. 下载包

3. 看文档 看dom

4. 使用



##### 使用Ajax==必须==引入jquery

在写css时加上特殊前缀,这样写的好处是不会覆盖第三方插件,更改css时也能知道是谁写的这个css样式

发现功能繁琐使用插件解决



## 权限

1. 只有当前用户和文章作者一致时可以编辑当前文章

后台获取参数的发送

1. url地址中获取参数
   1. req.query
2. 动态路由
   1. req.params
3. 获取用户post传输的数据
   1. req.body 



## 密码加密

1. 添加插件

   bcrypt

2. 定义加密的幂次

   const saltRounds = 10

3. 调用bcrypt.hash(被加密的密码,循环的幂次,回调函数)

4. 对比密码是否一致
  
   1. bcrypt.compare('用户输入的密码',数据库存储的密码,回调函数)

## 将网站发布服务器

### 开发模式

1. 了解过前后台分离模式,了解过前后台一起开发的模式

### ==跨越==

1. jsonp跨越原理利用script脚本形式实现,只支持get方式,是前端技术
2. cors跨域原理是通过服务器的技术 跨域名 是后台技术
3. 解决方法:
   1. 服务器
      1. 引入cors()模块跨越
      2. 原生方法:添加指定域名实现跨越
   2. 浏览器 
      1. 设置浏览器的禁用安全属性
4. 开发的过程中，不需要后台设置，我们前台通过设置禁用浏览器的安全策略，也可以实现跨域的效果

### 框架(实现快速开发)

1. bootstrap
2. semantic-ui
   1. 使用技术
      - 轮播图

instanceof :判断指定的对象是否为特定的实例

## 递归(自己调用自己)

​	简单的理解就是自己调用自己,但是自己一直调用自己会出现死循环,所有必须有一个返回值或是使用一个条件当条件满足时停止调用自己.这种定义在数学中十分常见,比如说数字1是一个自然数,而每一个自然数都于一个后继,所有同理这个后继一定是一个自然数.仔细的观察构成递归的条件和循环很像,都是循环同一个时间当满足条件时跳出,那么为什么还要使用递归?为了提高代码的重用性

## 闭包

在一个函数的内部调用另外一个函数

## js三大特性:继承 -- 封装 -- 多态

==面向对象==:

先从字面上理解

对象:

JavaScript中有万物皆对象的说法,这个说法是怎么来的?

​	对象是什么,所谓的对象实际是指'事物',这个事物包括人和物.在JavaScript中对象于属性和方法,怎么客观的形容这个抽象的概念.打个比方,笔是一个对象,他有形状,颜色和大小那么形状,颜色和大小是属性,笔可以用来写字那么写字就是方法,怎么使用笔写字就是对象执行的过程.

```
代码解释原型,原型链
let arr=[1,2]
arr.push
先找arr自己,没有找到就根据原型(__proto__原型对象)向上查找知道找到未知
对象的原型=原型对象
所有函数都有对象,所有对象都有原型,原型的constructor属性始终指向函数实例
因为arr.prototype里有push方法所以可以arr.push
```

​	因为很多情况下原生类型会被自动转换为对象,而每一个函数都有prototype属性,prototype指向一个对象,而prototype就其到了类的作用.,所以面向对象就

## ECMAScript 有两种开发模式：

1. 函数式(过程化)

2. 面向对象(OOP)。

面向对象的语言有一个标志，那就是类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是，ECMAScript 没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。

js本身是没有class类型的，但是每个函数都有一个prototype属性。prototype指向一个对象，当函数作为构造函数时，prototype则起到类似class的作用。





## 关键字

==name==不能当作变量名,因为name是js内置对象,之间使用name为变量名会报错,所以在定义变量名时要避免使用js关键字或预保留关键字



```
str.indexOf('?') 获取满足()里的第一个条件的下标

str.substr()截取字符串

.split()数组转字符串

.join()字符串转数组

forEach(item=>{})变量数组

-1就是没有(一般用在判断)
```

##### async:false, 将**Ajax**异步任务改变为同步任务

移动端 : 下拉刷新,上拉加载

使用插件还需要观察css 和js的影响

```
pc端
弹出框:
confirm("提示框")
上传文件是上传到本地地址
```



> fs.readFile 异步获取文件
>
> fs.readFileSync 同步获取文件



## 写程序以结果为导向

**webapi**执行过程 谁 -- 做什么 -- 过程

**事件源** -- 事件类型 -- 处理函数

## 使用一些数字来代表业务上的一些属性

1. 升序降序:0升序  1降序
2. 伪删除:0删除 1未删除
3. 性别:1男 2女



## 函数this的指向

1. 函数调用才会产生this
2. 函数里的this是谁调用指向谁(箭头函数没有this,构造函数,call/apply/bind不适用)

3. 对于多个函数嵌套调用需要注意this指向问题,

4. 小技巧: 定义一个变量将this保存起来

## 找插件 

> 框架名+插件名    省市区



字符串  '1'/0为真   ''/0 false/NeN假

## 数据的来源

数据的持久储存:数据库(网络) 本地存储(本地) 浏览器数据库

## 移动端手势事件

1. ​		**tap** 轻触
2. ​       **doubletap** 连续两次轻触
3. ​       **press** 长按
4. ​       **pan** 平移
5. ​       **flick** 轻拂

### 多指触控

1. ​       **touches**当前屏幕上所有触摸点的集合列表
2. ​       **targetTouches**绑定事件的那个结点上的触摸点的集合列表
3. ​       **changedTouches**触发事件时改变的触摸点的集合

## 工具

npm install

**bootstrap**依赖jQuery

正则比较强力

上传文件插件fileload

七牛云:托管文件(将自己的资源托管起来,减少服务器的压力,服务器里存储地址.尤其是上传图片)

proxy:代理

## 技巧

多个操作公用一个页面,使用状态来判断执行的那个操作, 一个页面能公用就公用

load  css,js,dom

boast :提示框插件





## 登陆拦截

判断当前用户是否登陆如果没有登陆就强制跳转到登陆页面让用户登陆.就向爱奇艺的会员视频只有会员登陆了才能观看,普通用户和为登陆用户不能观看,原理是一样的

## vue

v-if / v-show的区别

1. DOM结构中的形式
   1. v-if 在dom中没有
   2. v-show切换`display:none`属性
2. 使用场景
   1. 频繁的切换使用v-show
   2. 只渲染一次之后都不操作使用v-if

key**必须加** 推荐值使用`item.id`

- 标识唯一性,表示当前一一对应的关系(不能使用可能会重复的值)
- 参数值只能使用`numder`/`string`
- 必须使用`v-bing`绑定`key`
- 在组件中/特殊情况下v-for出现bug,添加`key`指定唯一字符串/数字解决bug

### 

vue函数中不添加`return`不会显示数据

padStart() / padEnd() 字符串补位

1. 参数: 指定长度 ,补什么字符串

2. 就是当字符串不满足指定长度时,将定义的字符补充到字符串中使字符串满足长度,padStart() 是在字符串前面补充,padEnd()是在字符串后面补充

form表单中有默认行为

数据存储:

1. 本地
2. 内存
3. 数据库

axios:8个生命周期

vue自定义属性有5个钩子函数 常用有bind , inserted , update使用场景:bind --> css , inserted  --> js , update -->组件更新时

生命周期 钩子函数



​	beforeMount和mounted的区别

​		beforeMount数据变模板,然后渲染为内存中的DOM

​		mounted内存中的模板挂载到页面中

使用过vue-resourve,axios,了解过promi